import streamlit as st
import pandas as pd
import numpy as np
import datetime
import matplotlib.pyplot as plt
from scipy.optimize import newton
from fpdf import FPDF
import base64

# ==========================================
# üß† FRIDAY QUANT ENGINE (v3.0)
# ==========================================

class IndianBondQuant:
    def __init__(self, face_value=100, freq=2):
        self.fv = face_value
        self.freq = freq

    @staticmethod
    def day_count_30_360(start_date, end_date):
        d1 = min(30, start_date.day)
        d2 = min(30, end_date.day) if d1 == 30 else end_date.day
        return 360 * (end_date.year - start_date.year) + 30 * (end_date.month - start_date.month) + (d2 - d1)

    def get_cash_flows(self, maturity_date, settle_date, coupon_rate, is_floating=False, ref_rate=0.0):
        dates = []
        curr = maturity_date
        while curr > settle_date:
            dates.append(curr)
            curr = curr - datetime.timedelta(days=365//self.freq)
        dates.sort()
        
        # FRN Logic: If floating, Coupon = Reference Rate + Spread (coupon_rate here acts as spread)
        effective_coupon = (ref_rate + coupon_rate) if is_floating else coupon_rate
        
        cf_amt = (self.fv * effective_coupon) / self.freq
        flows = []
        for i, d in enumerate(dates):
            amt = cf_amt
            if i == len(dates) - 1: amt += self.fv
            days = self.day_count_30_360(settle_date, d)
            t = days / 360.0
            flows.append({'date': d, 't': t, 'cf': amt})
        return pd.DataFrame(flows)

    def price_bond(self, flows, ytm):
        flows['df'] = 1 / ((1 + ytm/self.freq) ** (flows['t'] * self.freq))
        flows['pv'] = flows['cf'] * flows['df']
        return flows['pv'].sum()

    def calculate_risk_metrics(self, flows, ytm, price):
        if price == 0: return 0, 0, 0
        mac_num = (flows['t'] * flows['pv']).sum()
        mac_dur = mac_num / price
        mod_dur = mac_dur / (1 + ytm/self.freq)
        
        dy = 0.0001
        p_up = self.price_bond(flows, ytm + dy)
        p_down = self.price_bond(flows, ytm - dy)
        convexity = (p_down + p_up - 2 * price) / (price * dy**2)
        pv01 = (p_down - p_up) / 2
        return mod_dur, convexity, pv01

    @staticmethod
    def nelson_siegel_svensson(t, beta0, beta1, beta2, beta3, tau1, tau2):
        """Standard NSS Model for Yield Curve Fitting"""
        term1 = (1 - np.exp(-t/tau1)) / (t/tau1)
        term2 = term1 - np.exp(-t/tau1)
        term3 = ((1 - np.exp(-t/tau2)) / (t/tau2)) - np.exp(-t/tau2)
        return beta0 + beta1*term1 + beta2*term2 + beta3*term3

# ==========================================
# üìÑ REPORT GENERATOR (PDF)
# ==========================================
def create_pdf_report(bond_data, risk_data):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    
    pdf.set_font("Arial", 'B', 16)
    pdf.cell(200, 10, txt="Friday Fixed Income Valuation Report", ln=1, align='C')
    pdf.ln(10)
    
    pdf.set_font("Arial", size=12)
    pdf.cell(200, 10, txt=f"Valuation Date: {datetime.date.today()}", ln=1)
    pdf.ln(5)
    
    # Valuation Table
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(200, 10, txt="1. Valuation Summary", ln=1)
    pdf.set_font("Arial", size=12)
    pdf.cell(100, 10, txt=f"Bond Type: {bond_data['type']}", ln=1)
    pdf.cell(100, 10, txt=f"Maturity: {bond_data['mat']}", ln=1)
    pdf.cell(100, 10, txt=f"Coupon: {bond_data['cpn']}", ln=1)
    pdf.cell(100, 10, txt=f"Fair Price: INR {risk_data['price']:.2f}", ln=1)
    
    pdf.ln(10)
    pdf.set_font("Arial", 'B', 14)
    pdf.cell(200, 10, txt="2. Risk Metrics", ln=1)
    pdf.set_font("Arial", size=12)
    pdf.cell(100, 10, txt=f"Modified Duration: {risk_data['md']:.2f}", ln=1)
    pdf.cell(100, 10, txt=f"Convexity: {risk_data['cv']:.2f}", ln=1)
    pdf.cell(100, 10, txt=f"PV01: INR {risk_data['pv01']:.4f}", ln=1)
    
    pdf.ln(10)
    pdf.set_font("Arial", 'I', 10)
    pdf.cell(200, 10, txt="Generated by Friday FIT Terminal. For educational use only.", ln=1)
    
    return pdf.output(dest='S').encode('latin-1')

# ==========================================
# üñ•Ô∏è FRIDAY TERMINAL UI (v3.0)
# ==========================================
st.set_page_config(page_title="Friday FIT Ultimate", layout="wide", page_icon="üíπ")

# Initialize Session State for Portfolio
if 'portfolio' not in st.session_state:
    st.session_state['portfolio'] = []

st.markdown("""
<style>
    .stApp {background-color: #0e1117;}
    h1, h2, h3 {color: #ffffff; font-family: 'Roboto', sans-serif;}
    .stMetric {background-color: #1e272e; padding: 10px; border-radius: 8px;}
    div[data-testid="stMetricValue"] {color: #00d2d3;}
    .reportview-container .main .block-container{padding-top: 1rem;}
</style>
""", unsafe_allow_html=True)

st.title("üíπ Friday FIT: Ultimate Edition")
st.markdown("**Institutional Fixed Income Analytics | NSS Curve | Portfolio Mgmt | Reports**")

# MAIN TABS
tabs = st.tabs(["üìä Pricing Desk", "üíº Portfolio Manager", "üìâ NSS Curve Master", "üé≤ Monte Carlo"])

quant = IndianBondQuant(face_value=100, freq=2)

# ==========================================
# TAB 1: PRICING DESK (With Floating Rate & PDF)
# ==========================================
with tabs[0]:
    c_in, c_out = st.columns([1, 2])
    
    with c_in:
        st.markdown("### Bond Specs")
        bond_type = st.selectbox("Bond Structure", ["Fixed Rate Bond", "Floating Rate Note (FRN)"])
        
        is_float = True if "Floating" in bond_type else False
        
        if is_float:
            ref_rate = st.number_input("Reference Rate (MIBOR %)", value=6.50) / 100
            spread = st.number_input("Spread (bps)", value=100.0) / 10000
            coupon_input = spread # For FRN, coupon is spread
            disp_cpn = f"MIBOR + {spread*10000:.0f} bps"
        else:
            ref_rate = 0.0
            coupon_input = st.number_input("Coupon Rate (%)", value=7.50, step=0.1) / 100
            disp_cpn = f"{coupon_input*100:.2f}%"
            
        ytm = st.number_input("Market Yield (%)", value=7.20, step=0.05) / 100
        mat_date = st.date_input("Maturity", datetime.date.today() + datetime.timedelta(days=365*5))
        settle_date = datetime.date.today() + datetime.timedelta(days=1)
        
    with c_out:
        # Calculate
        flows = quant.get_cash_flows(mat_date, settle_date, coupon_input, is_float, ref_rate)
        price = quant.price_bond(flows, ytm)
        mod_dur, conv, pv01 = quant.calculate_risk_metrics(flows, ytm, price)
        
        # Metrics
        m1, m2, m3 = st.columns(3)
        m1.metric("Clean Price", f"‚Çπ {price:,.2f}")
        m2.metric("Mod Duration", f"{mod_dur:.2f}")
        m3.metric("PV01", f"‚Çπ {pv01:.3f}")
        
        # Actions
        a1, a2 = st.columns(2)
        with a1:
            if st.button("‚ûï Add to Portfolio"):
                st.session_state['portfolio'].append({
                    "id": len(st.session_state['portfolio'])+1,
                    "type": bond_type,
                    "mat": str(mat_date),
                    "cpn": disp_cpn,
                    "price": price,
                    "dur": mod_dur
                })
                st.success("Bond added to Portfolio!")
                
        with a2:
            # PDF Logic
            bond_meta = {'type': bond_type, 'mat': str(mat_date), 'cpn': disp_cpn}
            risk_meta = {'price': price, 'md': mod_dur, 'cv': conv, 'pv01': pv01}
            pdf_bytes = create_pdf_report(bond_meta, risk_meta)
            st.download_button("üìÑ Download PDF Report", data=pdf_bytes, file_name="Friday_Bond_Report.pdf", mime='application/pdf')

# ==========================================
# TAB 2: PORTFOLIO MANAGER (New Feature)
# ==========================================
with tabs[1]:
    st.markdown("### üíº Active Bond Portfolio")
    
    if len(st.session_state['portfolio']) > 0:
        df_port = pd.DataFrame(st.session_state['portfolio'])
        
        # Aggregate Metrics
        st.markdown("#### Portfolio Aggregates")
        avg_dur = df_port['dur'].mean() # Simplified Equal Weight
        total_val = df_port['price'].sum()
        
        p1, p2, p3 = st.columns(3)
        p1.metric("Total Holdings", len(df_port))
        p2.metric("Total Market Value", f"‚Çπ {total_val:,.2f}")
        p3.metric("Avg Portfolio Duration", f"{avg_dur:.2f}")
        
        st.dataframe(df_port, use_container_width=True)
        
        if st.button("Clear Portfolio"):
            st.session_state['portfolio'] = []
            st.experimental_rerun()
    else:
        st.info("Portfolio is empty. Go to 'Pricing Desk' and click 'Add to Portfolio'.")

# ==========================================
# TAB 3: NSS CURVE MASTER (New Feature)
# ==========================================
with tabs[2]:
    st.markdown("### üìâ Nelson-Siegel-Svensson (NSS) Curve Fitting")
    st.caption("Standard Central Bank model to smooth the yield curve.")
    
    col_params, col_viz = st.columns([1, 2])
    
    with col_params:
        st.markdown("**NSS Parameters**")
        beta0 = st.slider("Beta 0 (Long Term)", 0.0, 10.0, 7.5) / 100
        beta1 = st.slider("Beta 1 (Short Term)", -5.0, 5.0, -1.0) / 100
        beta2 = st.slider("Beta 2 (Hump)", -5.0, 5.0, -0.5) / 100
        tau1 = st.slider("Tau 1 (Location)", 0.1, 5.0, 2.0)
        
    with col_viz:
        t_seq = np.linspace(0.1, 30, 100)
        # Simplified NSS (using Beta3=0 for NS version for simplicity)
        y_seq = [quant.nelson_siegel_svensson(t, beta0, beta1, beta2, 0, tau1, 1.0) * 100 for t in t_seq]
        
        fig, ax = plt.subplots(figsize=(10, 4))
        ax.plot(t_seq, y_seq, color='#fdcb6e', lw=3, label='Fitted Curve')
        ax.set_title("NSS Fitted Sovereign Yield Curve", color='white')
        ax.set_xlabel("Maturity (Years)")
        ax.set_ylabel("Yield (%)")
        ax.set_facecolor('#0e1117')
        fig.patch.set_facecolor('#0e1117')
        ax.tick_params(colors='white', labelcolor='white')
        ax.grid(True, linestyle='--', alpha=0.3)
        st.pyplot(fig)
        
    st.info("üí° **Quant Note:** Adjust Beta parameters to see how the curve shifts, steepens, or twists. This simulates RBI monetary policy shifts.")

# ==========================================
# TAB 4: MONTE CARLO
# ==========================================
with tabs[3]:
    st.markdown("### üé≤ Monte Carlo Risk Simulator")
    
    # Simple Vasicek Implementation (from prev version)
    r0 = 0.07; theta = 0.075; sigma = 0.02; kappa = 0.5
    
    if st.button("Run Simulation"):
        dt = 1/252
        paths = 200
        T = 5
        N = int(T / dt)
        rates = np.zeros((paths, N))
        rates[:, 0] = r0
        
        for t in range(1, N):
            dr = kappa * (theta - rates[:, t-1]) * dt + sigma * np.sqrt(dt) * np.random.normal(0, 1, paths)
            rates[:, t] = rates[:, t-1] + dr
            
        fig_sim, ax_sim = plt.subplots(figsize=(10, 4))
        ax_sim.plot(np.linspace(0, T, N), rates.T, color='#6c5ce7', alpha=0.05)
        ax_sim.plot(np.linspace(0, T, N), rates.mean(axis=0), color='white', lw=2)
        ax_sim.set_facecolor('#0e1117')
        fig_sim.patch.set_facecolor('#0e1117')
        ax_sim.tick_params(colors='white')
        ax_sim.set_title("Interest Rate Path Simulation (Vasicek Model)", color='white')
        st.pyplot(fig_sim)
